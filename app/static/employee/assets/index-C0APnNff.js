import{W as t,i as g,b,t as y,a as p,c as w,d as u,e as _}from"./index-DStTAuaa.js";import{_ as D,f as K,g as U,s as C}from"./index-DStTAuaa.js";function O({error:e,options:a}){const{publicKey:i}=a;if(!i)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(a.signal instanceof AbortSignal)return new t({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(i.authenticatorSelection?.requireResidentKey===!0)return new t({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(a.mediation==="conditional"&&i.authenticatorSelection?.userVerification==="required")return new t({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(i.authenticatorSelection?.userVerification==="required")return new t({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new t({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new t({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return i.pubKeyCredParams.filter(s=>s.type==="public-key").length===0?new t({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new t({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const o=globalThis.location.hostname;if(g(o)){if(i.rp.id!==o)return new t({message:`The RP ID "${i.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new t({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new t({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new t({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function S(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:a,useAutoRegister:i=!1}=e;if(!b())throw new Error("WebAuthn is not supported in this browser");const o={...a,challenge:p(a.challenge),user:{...a.user,id:p(a.user.id)},excludeCredentials:a.excludeCredentials?.map(y)},s={};i&&(s.mediation="conditional"),s.publicKey=o,s.signal=w.createNewAbortSignal();let c;try{c=await navigator.credentials.create(s)}catch(r){throw O({error:r,options:s})}if(!c)throw new Error("Registration was not completed");const{id:A,rawId:E,response:n,type:m}=c;let d;typeof n.getTransports=="function"&&(d=n.getTransports());let R;if(typeof n.getPublicKeyAlgorithm=="function")try{R=n.getPublicKeyAlgorithm()}catch(r){l("getPublicKeyAlgorithm()",r)}let f;if(typeof n.getPublicKey=="function")try{const r=n.getPublicKey();r!==null&&(f=u(r))}catch(r){l("getPublicKey()",r)}let h;if(typeof n.getAuthenticatorData=="function")try{h=u(n.getAuthenticatorData())}catch(r){l("getAuthenticatorData()",r)}return{id:A,rawId:u(E),response:{attestationObject:u(n.attestationObject),clientDataJSON:u(n.clientDataJSON),transports:d,publicKeyAlgorithm:R,publicKey:f,authenticatorData:h},type:m,clientExtensionResults:c.getClientExtensionResults(),authenticatorAttachment:_(c.authenticatorAttachment)}}function l(e,a){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,a)}function T(){return b()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}export{w as WebAuthnAbortService,t as WebAuthnError,D as _browserSupportsWebAuthnAutofillInternals,K as _browserSupportsWebAuthnInternals,p as base64URLStringToBuffer,b as browserSupportsWebAuthn,U as browserSupportsWebAuthnAutofill,u as bufferToBase64URLString,T as platformAuthenticatorIsAvailable,C as startAuthentication,S as startRegistration};
